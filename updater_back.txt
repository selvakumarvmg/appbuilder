# import os
# import sys
# import time
# import shutil
# import subprocess
# import ctypes
# import traceback

# def run_as_admin():
#     """ Relaunch this script with admin rights if not already elevated """
#     try:
#         if ctypes.windll.shell32.IsUserAnAdmin():
#             return True
#     except:
#         pass

#     params = " ".join([f'"{a}"' for a in sys.argv])
#     # üîπ Relaunch self as admin
#     ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, params, None, 1)
#     sys.exit(0)

# def main():
#     if len(sys.argv) < 3:
#         print("Usage: updater.exe <old_path> <new_path>")
#         sys.exit(1)

#     # --- Fix duplicate self path added by ShellExecuteW ---
#     if len(sys.argv) >= 4 and sys.argv[1].endswith("updater.exe"):
#         sys.argv.pop(1)        

#     # Correct argument mapping
#     new_path = sys.argv[1]  # The new downloaded file (from temp)
#     old_path = sys.argv[2]  # The currently installed app (PremediaApp.exe)

#     # üîπ Ensure elevated privileges
#     run_as_admin()

#     log_path = os.path.join(os.path.dirname(old_path), "update_log.txt")

#     with open(log_path, "a", encoding="utf-8") as log:
#         log.write(f"\n[{time.ctime()}] ======== UPDATE START ========\n")
#         log.write(f"Old: {old_path}\nNew: {new_path}\n")

#         # üîπ Step 1: Wait until old app fully exits
#         for i in range(30):  # wait up to 30 seconds
#             try:
#                 os.rename(old_path, old_path)  # test if file is free
#                 log.write("‚úÖ File lock released.\n")
#                 break
#             except PermissionError:
#                 log.write(f"‚è≥ Waiting for app to close... ({i+1}/30)\n")
#                 time.sleep(1)
#         else:
#             log.write("‚ùå Timeout: app did not close in 30 seconds.\n")
#             sys.exit(1)

#         # üîπ Step 2: Copy new version ‚Üí old app location
#         try:
#             if not os.path.exists(new_path):
#                 log.write(f"‚ùå New file missing: {new_path}\n")
#                 sys.exit(1)

#             shutil.copy2(new_path, old_path)
#             log.write("‚úÖ New version copied successfully.\n")
#         except Exception as e:
#             log.write(f"‚ùå Copy failed: {e}\n{traceback.format_exc()}\n")
#             sys.exit(1)

#         # üîπ Step 3: Delete temp file safely
#         try:
#             os.remove(new_path)
#             log.write("üßπ Temp file removed.\n")
#         except Exception as e:
#             log.write(f"‚ö†Ô∏è Could not delete temp file: {e}\n")

#         # üîπ Step 4: Relaunch the updated app
#         try:
#             subprocess.Popen([old_path], shell=False)
#             log.write("üöÄ Relaunched new version successfully.\n")
#         except Exception as e:
#             log.write(f"‚ùå Relaunch failed: {e}\n{traceback.format_exc()}\n")

#         log.write("‚úÖ ======== UPDATE COMPLETE ========\n")


# if __name__ == "__main__":
#     main()


# import os
# import sys
# import time
# import shutil
# import subprocess
# import ctypes
# import traceback


# def run_as_admin():
#     """ Relaunch this script with admin rights if not already elevated """
#     try:
#         if ctypes.windll.shell32.IsUserAnAdmin():
#             return True
#     except:
#         pass

#     params = " ".join([f'"{a}"' for a in sys.argv])
#     ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, params, None, 1)
#     sys.exit(0)


# def wait_for_file_release(path, log, timeout=30):
#     """ Waits until the file is not locked by any process """
#     for i in range(timeout):
#         # Check write permission
#         if os.access(path, os.W_OK):
#             try:
#                 os.rename(path, path)  # Windows-like lock test
#                 log.write("‚úÖ File lock released.\n")
#                 return True
#             except PermissionError:
#                 pass

#         log.write(f"‚è≥ Waiting for file to unlock... ({i+1}/{timeout})\n")
#         time.sleep(1)

#     return False


# def main():
#     if len(sys.argv) < 3:
#         print("Usage: updater.exe <new_path> <old_path>")
#         sys.exit(1)

#     # Remove duplicated self-inserted path when elevated
#     if len(sys.argv) >= 4 and "updater" in sys.argv[1].lower():
#         sys.argv.pop(1)

#     new_path = sys.argv[1]
#     old_path = sys.argv[2]

#     # Run as admin if needed
#     run_as_admin()

#     log_path = os.path.join(os.path.dirname(old_path), "update_log.txt")

#     with open(log_path, "a", encoding="utf-8") as log:
#         log.write(f"\n[{time.ctime()}] ======== UPDATE START ========\n")
#         log.write(f"Old: {old_path}\nNew: {new_path}\n")

#         # 1Ô∏è‚É£ Wait for the old EXE to be free
#         if not wait_for_file_release(old_path, log):
#             log.write("‚ùå Timeout: app never released the file.\n")
#             sys.exit(1)

#         # 2Ô∏è‚É£ Delete old exe first (prevents PermissionError)
#         try:
#             log.write("üóë Deleting old version...\n")
#             os.remove(old_path)
#         except Exception as e:
#             log.write(f"‚ùå Failed to delete old file: {e}\n{traceback.format_exc()}\n")
#             sys.exit(1)

#         # 3Ô∏è‚É£ Copy new exe into place
#         try:
#             if not os.path.exists(new_path):
#                 log.write(f"‚ùå New file missing: {new_path}\n")
#                 sys.exit(1)

#             log.write("üìÑ Copying new version...\n")
#             shutil.copy2(new_path, old_path)
#             log.write("‚úÖ New version copied successfully.\n")
#         except Exception as e:
#             log.write(f"‚ùå Copy failed: {e}\n{traceback.format_exc()}\n")
#             sys.exit(1)

#         # 4Ô∏è‚É£ Delete temp file
#         try:
#             os.remove(new_path)
#             log.write("üßπ Temp file removed.\n")
#         except Exception as e:
#             log.write(f"‚ö†Ô∏è Could not delete temp file: {e}\n")

#         # 5Ô∏è‚É£ Relaunch updated EXE
#         try:
#             subprocess.Popen([old_path], shell=False)
#             log.write("üöÄ Relaunched updated version.\n")
#         except Exception as e:
#             log.write(f"‚ùå Relaunch failed: {e}\n{traceback.format_exc()}\n")

#         log.write("‚úÖ ======== UPDATE COMPLETE ========\n")


# if __name__ == "__main__":
#     main()
# ------------------------------------------------------>


import os
import sys
import time
import shutil
import subprocess
import ctypes
import traceback


def run_as_admin():
    """Relaunch this script with admin rights if not already elevated."""
    try:
        if ctypes.windll.shell32.IsUserAnAdmin():
            return True
    except Exception:
        # If check fails, try to elevate anyway
        pass

    params = " ".join([f'"{a}"' for a in sys.argv])
    rc = ctypes.windll.shell32.ShellExecuteW(
        None, "runas", sys.executable, params, None, 1
    )
    # If elevation launched successfully, exit current (non‚Äëadmin) process
    if rc > 32:
        sys.exit(0)
    else:
        raise RuntimeError(f"UAC elevation failed with code {rc}")


def wait_for_file_release(path, log, timeout=30):
    """Waits until the file is not locked by any process (best-effort)."""
    for i in range(timeout):
        if os.access(path, os.W_OK):
            try:
                # simple lock test
                os.rename(path, path)
                log.write("‚úÖ File lock released.\n")
                return True
            except PermissionError:
                pass

        log.write(f"‚è≥ Waiting for file to unlock... ({i + 1}/{timeout})\n")
        time.sleep(1)

    return False


def main():
    if len(sys.argv) < 3:
        print("Usage: updater.exe <new_path> <old_path>")
        sys.exit(1)

    # Remove duplicated self-inserted path when elevated
    if len(sys.argv) >= 4 and "updater" in sys.argv[1].lower():
        sys.argv.pop(1)

    new_path = sys.argv[1]
    old_path = sys.argv[2]

    # Ensure this instance is elevated
    if not run_as_admin():
        sys.exit(1)

    log_path = os.path.join(os.path.dirname(old_path), "update_log.txt")

    with open(log_path, "a", encoding="utf-8") as log:
        log.write(f"\n[{time.ctime()}] ======== UPDATE START ========\n")
        log.write(f"Old: {old_path}\nNew: {new_path}\n")

        # 1Ô∏è‚É£ Wait for the old EXE to be free (best-effort)
        if not wait_for_file_release(old_path, log):
            log.write("‚ùå Timeout: app never released the file.\n")
            sys.exit(1)

        # 2Ô∏è‚É£ Safely rotate old exe instead of deleting
        backup = old_path + ".old"
        try:
            # Try to cleanup previous backup if it exists
            if os.path.exists(backup):
                try:
                    os.remove(backup)
                    log.write("üßπ Previous backup removed.\n")
                except PermissionError as e:
                    log.write(f"‚ö†Ô∏è Could not delete previous backup: {e}\n")

            log.write("‚ôªÔ∏è Renaming old exe to backup...\n")
            os.rename(old_path, backup)
            log.write("‚úÖ Old exe renamed to backup.\n")
        except Exception as e:
            log.write(f"‚ùå Failed to rotate old exe: {e}\n{traceback.format_exc()}\n")
            sys.exit(1)

        # 3Ô∏è‚É£ Copy new exe into place
        try:
            if not os.path.exists(new_path):
                log.write(f"‚ùå New file missing: {new_path}\n")
                sys.exit(1)

            log.write("üìÑ Copying new version...\n")
            shutil.copy2(new_path, old_path)
            log.write("‚úÖ New version copied successfully.\n")
        except Exception as e:
            log.write(f"‚ùå Copy failed: {e}\n{traceback.format_exc()}\n")
            # Optional: try to restore backup on failure
            try:
                if os.path.exists(backup):
                    shutil.copy2(backup, old_path)
                    log.write("‚Ü©Ô∏è Restored old exe from backup.\n")
            except Exception as e2:
                log.write(f"‚ö†Ô∏è Failed to restore old exe: {e2}\n")
            sys.exit(1)

        # 4Ô∏è‚É£ Delete temp file
        try:
            os.remove(new_path)
            log.write("üßπ Temp file removed.\n")
        except Exception as e:
            log.write(f"‚ö†Ô∏è Could not delete temp file: {e}\n")

        # 5Ô∏è‚É£ Relaunch updated EXE
        try:
            subprocess.Popen([old_path], shell=False)
            log.write("üöÄ Relaunched updated version.\n")
        except Exception as e:
            log.write(f"‚ùå Relaunch failed: {e}\n{traceback.format_exc()}\n")

        log.write("‚úÖ ======== UPDATE COMPLETE ========\n")


if __name__ == "__main__":
    main()


    
# ------------------------------>

# ------------------------->  bat---->
# import sys
# import subprocess
# import os

# def main():
#     if len(sys.argv) < 3:
#         print("Usage: updater.py <new_file_path> <old_exe_path>")
#         sys.exit(1)

#     new_file = sys.argv[1]
#     old_exe = sys.argv[2]

#     bat_path = os.path.join(os.path.dirname(old_exe), "updater.bat")

#     if not os.path.exists(bat_path):
#         print(f"‚ùå updater.bat not found: {bat_path}")
#         sys.exit(1)

#     print(f"[Updater.py] Starting batch updater...")
#     print(f"[Updater.py] Old exe: {old_exe}")
#     print(f"[Updater.py] New file: {new_file}")

#     # Run the .bat file in a new minimized cmd window
#     subprocess.Popen(["cmd", "/c", "start", "/min", "cmd", "/c", bat_path, old_exe, new_file])
#     sys.exit(0)  # exit immediately so exe can be replaced

# if __name__ == "__main__":
#     main()

--------------------------------------------------------------------------------------->





# # updater_client.py
# import os, sys, json, tempfile, subprocess, hashlib, platform, requests, tkinter as tk
# from tkinter import messagebox

# # CloudFront base URL
# VERSION_URL = "https://vmg-premedia-22112023.s3.ap-southeast-2.amazonaws.com/application/drn/latest_version.json"


# def sha256(path):
#     h = hashlib.sha256()
#     with open(path, "rb") as f:
#         for chunk in iter(lambda: f.read(8192), b""):
#             h.update(chunk)
#     return h.hexdigest()

# def ask_user_to_update(latest):
#     root = tk.Tk()
#     root.withdraw()
#     res = messagebox.askyesno(
#         "Update Available",
#         f"A new version {latest} is available.\nDo you want to update now?"
#     )
#     root.destroy()
#     return res

# def check_for_update(current_version, exe_path):
#     try:
#         r = requests.get(VERSION_URL, timeout=5)
#         data = r.json()
#         latest = data["version"]

#         if latest != current_version:
#             if ask_user_to_update(latest):
#                 os_type = platform.system()
#                 if os_type == "Windows":
#                     url = data.get("windows_url")
#                 elif os_type == "Darwin":
#                     url = data.get("mac_url")
#                 else:
#                     print("Auto-update not supported on this OS.")
#                     return

#                 tmp = os.path.join(tempfile.gettempdir(), os.path.basename(url))
#                 print(f"Downloading update: {url}")
#                 with open(tmp, "wb") as f:
#                     f.write(requests.get(url).content)
#                 print(f"Downloaded to: {tmp}")
#                 print(data.get("sha256", ")"))
#                 if sha256(tmp).strip().upper() == data.get("sha256", "").strip().upper():
#                     print("Update downloaded successfully.")
#                     if os_type == "Windows":
#                         subprocess.Popen(["updater.exe", exe_path, tmp])
#                         sys.exit(0)
#                     elif os_type == "Darwin":
#                         subprocess.Popen(["open", tmp])  # open dmg/pkg
#                         sys.exit(0)
#                 else:
#                     messagebox.showerror("Update Error", "Checksum mismatch.")
#         else:
#             print(" Already up to date.")
#     except Exception as e:
#         print("Update check failed:", e)

# updater_client.py
import os
import sys
import json
import time
import tempfile
import subprocess
import hashlib
import platform
import requests
import tkinter as tk
from tkinter import messagebox

# üîπ S3 location of version file
VERSION_URL = "https://vmg-premedia-22112023.s3.ap-southeast-2.amazonaws.com/application/drn/latest_version.json"


# ====================================================
#  Utility functions
# ====================================================

def sha256(path):
    """Compute SHA256 checksum of a file."""
    h = hashlib.sha256()
    with open(path, "rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            h.update(chunk)
    return h.hexdigest().upper()


def ask_user_to_update(latest):
    """Ask user if they want to update."""
    root = tk.Tk()
    root.withdraw()
    res = messagebox.askyesno(
        "Update Available",
        f"A new version {latest} is available.\nDo you want to update now?"
    )
    root.destroy()
    return res


# ====================================================
#  Main update logic
# ====================================================

def check_for_update(current_version, exe_path):
    """
    Check remote JSON for new version, download and apply update if needed.
    """
    try:
        # üîπ Step 1: Fetch latest version JSON (with cache-busting)
        response = requests.get(f"{VERSION_URL}?t={int(time.time())}", timeout=8)
        data = response.json()
        latest_version = data.get("version", "").strip()

        if not latest_version:
            print("[Updater] ‚ùå No version info in JSON.")
            return

        print(f"[Updater] Current: {current_version} | Latest: {latest_version}")

        # üîπ Step 2: Compare versions
        if latest_version == current_version:
            print("[Updater] ‚úÖ Already up to date.")
            return

        # üîπ Step 3: Ask user for confirmation (unless mandatory)
        mandatory = bool(data.get("mandatory"))
        if not mandatory:
            if not ask_user_to_update(latest_version):
                print("[Updater] Skipped by user.")
                return
        else:
            print("[Updater] Mandatory update enforced.")

        # üîπ Step 4: Select correct OS download URL
        os_type = platform.system()
        if os_type == "Windows":
            download_url = data.get("windows_url")
        elif os_type == "Darwin":
            download_url = data.get("mac_url")
        else:
            messagebox.showinfo("Unsupported OS", "Auto-update is not supported on this OS.")
            return

        if not download_url:
            messagebox.showerror("Update Error", "Download URL missing in JSON.")
            return

        # üîπ Step 5: Download new build
        print(f"[Updater] Downloading from: {download_url}")
        tmp_file = os.path.join(tempfile.gettempdir(), os.path.basename(download_url))

        with requests.get(download_url, stream=True, timeout=30) as r:
            r.raise_for_status()
            with open(tmp_file, "wb") as f:
                for chunk in r.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)

        print(f"[Updater] Downloaded to temp: {tmp_file}")

        # üîπ Step 6: Verify SHA256 checksum
        expected_hash = data.get("sha256", "").strip().upper()
        actual_hash = sha256(tmp_file)

        print(f"[Updater] Expected SHA256: {expected_hash}")
        print(f"[Updater] Actual SHA256:   {actual_hash}")

        if expected_hash and actual_hash != expected_hash:
            messagebox.showerror("Update Error", "Checksum mismatch. Download may be corrupted.")
            os.remove(tmp_file)
            return

        # üîπ Step 7: Launch updater
        if os_type == "Windows":
            updater_path = os.path.join(os.path.dirname(exe_path), "updater.exe")

            if not os.path.exists(updater_path):
                messagebox.showerror("Update Error", f"Missing updater.exe at:\n{updater_path}")
                return

            print(f"[Updater] Launching updater: {updater_path}")
            subprocess.Popen([updater_path, tmp_file, exe_path])
            sys.exit(0)

        elif os_type == "Darwin":
            subprocess.Popen(["open", tmp_file])  # open DMG/pkg
            sys.exit(0)

    except requests.exceptions.RequestException as e:
        print(f"[Updater] Network error: {e}")
    except json.JSONDecodeError as e:
        print(f"[Updater] Invalid JSON file: {e}")
    except Exception as e:
        print(f"[Updater] Unexpected error: {e}")
